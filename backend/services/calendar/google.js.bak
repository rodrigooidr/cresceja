
const { google } = require('googleapis');
const { Client } = require('pg');
function getOAuthClient(){
  const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    process.env.GOOGLE_REDIRECT_URI
  );
  return oauth2Client;
}
async function saveTokens(userId, tokens){
  const client = new Client({ connectionString: process.env.DATABASE_URL });
  await client.connect();
  try{
    await client.query(
      `INSERT INTO calendar_integrations (user_id, provider, tokens) 
       VALUES ($1,'google',$2)
       ON CONFLICT (user_id, provider) DO UPDATE SET tokens=$2, updated_at=NOW()`,
      [userId, tokens]
    );
  }finally{ await client.end(); }
}
async function getTokens(userId){
  const client = new Client({ connectionString: process.env.DATABASE_URL });
  await client.connect();
  try{
    const r = await client.query(\`SELECT tokens FROM calendar_integrations WHERE user_id=$1 AND provider='google'\`, [userId]);
    return r.rows[0]?.tokens || null;
  }finally{ await client.end(); }
}
async function createEvent(userId, { summary, start, end }){
  const tokens = await getTokens(userId);
  if(!tokens) return { ok:false, error:'not_connected' };
  const oauth = getOAuthClient();
  oauth.setCredentials(tokens);
  const cal = google.calendar({ version: 'v3', auth: oauth });
  const { data } = await cal.freebusy.query({
    requestBody: { timeMin: new Date(start).toISOString(), timeMax: new Date(end).toISOString(), items: [{ id: 'primary' }] }
  });
  const busy = data?.calendars?.primary?.busy || [];
  if(busy.length) return { ok:false, error:'conflict', busy };
  await cal.events.insert({
    calendarId: 'primary',
    requestBody: { summary, start: { dateTime: new Date(start).toISOString() }, end: { dateTime: new Date(end).toISOString() } }
  });
  return { ok:true };
}
function getAuthUrl(state){
  const oauth = getOAuthClient();
  const scopes = ['https://www.googleapis.com/auth/calendar', 'https://www.googleapis.com/auth/userinfo.email'];
  return oauth.generateAuthUrl({ access_type: 'offline', scope: scopes, state });
}
async function handleCallback(code, userId){
  const oauth = getOAuthClient();
  const { tokens } = await oauth.getToken(code);
  await saveTokens(userId, tokens);
  return { ok:true };
}
module.exports = { getAuthUrl, handleCallback, createEvent };
